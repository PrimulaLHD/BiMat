
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>BiMat - Group Testing Use case</title><meta name="generator" content="MATLAB 7.13"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2013-05-22"><meta name="DC.source" content="use_case_group_testing.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h1>BiMat - Group Testing Use case</h1><!--introduction--><p>This use case will introduce the user to the functionalities about how to perform an statistical analysis of a group of bipartite networks (matrices). For doing that we will use the data from Flores et Al 2011. This data consist of 38 bipartite adjacency matrices of different sizes. Each matrix is named according to the first author paper from which it was extracted. We will perform an analysis of modularity and nestedness in the entire set.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Add the source to the matlab path</a></li><li><a href="#3">Creating a Group Testing object</a></li><li><a href="#4">Perform an statististical analysis in the set of matrices</a></li><li><a href="#7">Using a GroupTesting object to create your own plots</a></li></ul></div><h2>Add the source to the matlab path<a name="1"></a></h2><pre class="codeinput">g = genpath(<span class="string">'matlab'</span>); addpath(g);
</pre><p>We need also to load the data from which we will be working on</p><pre class="codeinput">load <span class="string">group_testing_data.mat</span>;
</pre><h2>Creating a Group Testing object<a name="3"></a></h2><p>If the number of random matrices and the null model are not assigned, 100 and AVERAGE are used as default. Here we will use 100 random matrices with the EQUIPROBABLE null model</p><pre class="codeinput">gp = GroupTesting(grouptesting.matrices);    <span class="comment">% Create the main object</span>
</pre><h2>Perform an statististical analysis in the set of matrices<a name="4"></a></h2><p>Suppose that we are interested in calculating the modularity and nestedness using the NTC algorithm as Flores et Al 2011 did. In addition, following the approach of Flores et Al 2011, we want to use the equiprobable model as null model in our random networks. The way to perform this analysis is by running the next lines:</p><pre class="codeinput">gp.replicates = 100; <span class="comment">%How many random networks we want for each matrix</span>
gp.null_model = @NullModels.EQUIPROBABLE; <span class="comment">%Our Null model</span>
gp.modul_class = @AdaptiveBrim; <span class="comment">%Algorithm for modularity.</span>
gp.do_temp = 1; <span class="comment">% Perform NTC analysis (default)</span>
gp.do_modul = 1; <span class="comment">% Perform Modularity analysis (default)</span>
gp.do_nest = 0; <span class="comment">% Do not perform NODF analysis</span>
gp.DoGroupTesting(); <span class="comment">% Perform the analysis.</span>
gp.names = grouptesting.name;
</pre><pre class="codeoutput">Testing Matrix: 1 . . .
Testing Matrix: 2 . . .
Testing Matrix: 3 . . .
Testing Matrix: 4 . . .
Testing Matrix: 5 . . .
Testing Matrix: 6 . . .
Testing Matrix: 7 . . .
Testing Matrix: 8 . . .
Testing Matrix: 9 . . .
Testing Matrix: 10 . . .
Testing Matrix: 11 . . .
Testing Matrix: 12 . . .
Testing Matrix: 13 . . .
Testing Matrix: 14 . . .
Testing Matrix: 15 . . .
Testing Matrix: 16 . . .
Testing Matrix: 17 . . .
Testing Matrix: 18 . . .
Testing Matrix: 19 . . .
Testing Matrix: 20 . . .
Testing Matrix: 21 . . .
Testing Matrix: 22 . . .
Testing Matrix: 23 . . .
Testing Matrix: 24 . . .
Testing Matrix: 25 . . .
Testing Matrix: 26 . . .
Testing Matrix: 27 . . .
Testing Matrix: 28 . . .
Testing Matrix: 29 . . .
Testing Matrix: 30 . . .
Testing Matrix: 31 . . .
Testing Matrix: 32 . . .
Testing Matrix: 33 . . .
Testing Matrix: 34 . . .
Testing Matrix: 35 . . .
Testing Matrix: 36 . . .
Testing Matrix: 37 . . .
Testing Matrix: 38 . . .
</pre><p>Notice that <tt>DoGroupTesting</tt> method prints informatino about the current networks that is being analyzed, such that the user will know at every moment the current status of the analysis. After the analysis is finished a simple statistical measure to say that a matrix is nested and/or modular is to chose a two tail p-value = 0.05 as Flores et al 2011 did. Therefore, the next lines of code will show how many matrices are found nested and/or modular</p><pre class="codeinput">fprintf(<span class="string">'Number of nested matrices: %i\n'</span>,sum(gp.tempvals.percent &gt;= 97.5));
fprintf(<span class="string">'Number of modular matrices: %i\n'</span>,sum(gp.qb_vals.percent &gt;= 97.5));
</pre><pre class="codeoutput">Number of nested matrices: 28
Number of modular matrices: 6
</pre><p>We can also show the entire set of results by calling:</p><pre class="codeinput">gp.PrintResults();
</pre><pre class="codeoutput">Network,      Qb, Qb mean,Qb z-score,Qb percent,    NTC,NTC mean,NTC z-score,NTC percent
      1, 0.30992,  0.2725,    1.2327,        90,0.65025, 0.67052,   -0.22294,         41
      2,  0.2144, 0.39445,   -4.6534,         0,0.80719, 0.68597,     1.5036,         93
      3, 0.17556, 0.24566,   -2.5167,         0,0.99985, 0.65432,     4.2961,        100
      4, 0.22449,  0.3974,   -3.2105,         0, 0.9352, 0.76142,     1.7771,         98
      5, 0.25652, 0.30855,    -3.232,         0,0.94489,  0.5412,     5.8702,        100
      6,  0.2699, 0.51093,    -3.752,         0,0.82486, 0.77839,    0.52604,         66
      7, 0.21403, 0.33127,   -4.0524,         0,0.98175, 0.63521,     4.4745,        100
      8,   0.174,  0.2439,   -8.5592,         0,0.79682, 0.42728,     8.6203,        100
      9, 0.21847,  0.3498,   -9.5682,         0,0.85738, 0.53824,     6.2772,        100
     10, 0.29191, 0.27721,   0.73223,        79,0.64081,  0.5953,    0.55611,         70
     11, 0.24033, 0.38503,   -6.2781,         0,0.82933, 0.62555,     2.7682,        100
     12,  0.4821, 0.40942,    2.8321,       100,0.88313, 0.64603,     3.0956,        100
     13, 0.32099, 0.48185,   -1.9035,         3,0.92493, 0.87895,    0.52222,         69
     14, 0.31667,  0.3471,   -1.0253,        13, 0.7877, 0.57241,     4.0343,        100
     15, 0.20023,  0.2645,   -6.4317,         0, 0.7204, 0.43858,     6.7092,        100
     16, 0.18956,  0.1932,  -0.82439,        18,0.83351, 0.33077,    15.3223,        100
     17,0.045608,  0.0505,   -1.9443,         3,0.99902, 0.84614,     4.1563,        100
     18,  0.1231, 0.15726,   -4.2506,         0,0.90103, 0.61106,     3.2975,        100
     19,       0, 0.27242,   -7.5124,         0,0.63018, 0.62703,   0.041239,         55
     20, 0.31027, 0.46582,   -7.4241,         0,0.85838, 0.64744,      4.397,        100
     21, 0.19136, 0.38623,   -5.0241,         0,0.97793, 0.71707,     2.4493,        100
     22, 0.22015, 0.18097,    6.8156,       100,0.98091, 0.35047,    18.2543,        100
     23, 0.08406, 0.10083,   -5.5755,         0,0.98762, 0.61508,     6.3951,        100
     24,  0.4102, 0.34665,    3.3977,       100,0.70452,  0.5557,     2.1083,         98
     25, 0.14966, 0.19721,   -2.0982,         2,0.85489, 0.78428,    0.63733,         70
     26,0.053624, 0.10161,   -7.8911,         0,0.87663, 0.60843,     5.6203,        100
     27, 0.20209,  0.2121,   -1.1958,        13,0.83435, 0.44318,    10.1753,        100
     28, 0.37357, 0.38948,    -1.071,        13,0.80759, 0.60341,     4.6099,        100
     29, 0.37622, 0.26283,    9.6229,       100,0.64478, 0.47891,     2.6561,        100
     30, 0.33347, 0.33635,  -0.18429,        46,0.93098, 0.54852,     5.6426,        100
     31, 0.22893, 0.46471,   -5.8266,         0,0.97517, 0.70831,     3.3961,        100
     32, 0.18341, 0.14726,    8.5928,       100,0.92829, 0.37107,    15.9167,        100
     33, 0.39459, 0.39206,   0.17837,        56,0.77942, 0.61182,     4.3341,        100
     34,  0.4876, 0.51901,  -0.41298,        31,0.90268, 0.88265,    0.30039,         52
     35,0.084203,0.085275,  -0.40407,        31,0.94813,  0.6889,     4.1243,        100
     36, 0.61983, 0.63826,  -0.21193,        38,0.96818, 0.94662,    0.73678,         76
     37, 0.21818, 0.27316,   -6.0374,         0,0.88818, 0.41832,    12.9331,        100
     38, 0.68222, 0.58183,    3.1725,       100,0.83306, 0.82483,     0.2164,         57
</pre><h2>Using a GroupTesting object to create your own plots<a name="7"></a></h2><p>We can use a GroupTesting object (gp in this case) to create specific plots. Suppose we are interested in plotting all the matrices in modular sorting, such that the lables in the matrix are in red if the matrix is modular and in blue if it is antimodular. A simple script for performing this task will be:</p><pre class="codeinput">n_rows = 5;
n_cols = 8;
modular_indices = gp.qb_vals.percent &gt;= 97.5;
no_modular_indices = gp.qb_vals.percent &lt;= 2.5;
figure(1);
<span class="keyword">for</span> i = 1:gp.n_networks
    subplot(n_rows, n_cols, i);
    gp.networks{i}.plotter.use_labels = 0; <span class="comment">%Do not show row/column labels</span>
    gp.networks{i}.plotter.use_isocline = 0; <span class="comment">%No isocline inside modules</span>
    gp.networks{i}.plotter.PlotModularMatrix();
    col = <span class="string">'black'</span>; <span class="comment">% Color for not significance</span>
    <span class="keyword">if</span>(modular_indices(i) == 1) <span class="comment">% Color for significant modularity</span>
        col = <span class="string">'red'</span>;
    <span class="keyword">elseif</span>(no_modular_indices(i) == 1) <span class="comment">% Color for significant antimodularity</span>
        col = <span class="string">'blue'</span>;
    <span class="keyword">end</span>
    title(gp.names{i},<span class="string">'Color'</span>,col, <span class="string">'FontSize'</span>,10);
<span class="keyword">end</span>
set(gcf,<span class="string">'Position'</span>, [148         213        1142         746]);
</pre><img vspace="5" hspace="5" src="use_case_group_testing_01.png" alt=""> <p>We may want to create a plot that compare the values of the networks with the random values of the null model. The next lines will show how to create such plot for the case of the NTC results</p><pre class="codeinput">ntc_vals = gp.tempvals.value;
[~,sorted_indexes] = sort(ntc_vals); <span class="comment">% I will plot in increasing NTC value</span>

<span class="comment">%Get random values and sort according to sorted_indexes</span>
ntc_vals = ntc_vals(sorted_indexes);
mean_random_vals = gp.tempvals.mean(sorted_indexes);
random_values = gp.tempvals.random_values; <span class="comment">%variable already sorted in rows</span>
random_values = random_values(sorted_indexes,:); <span class="comment">%sort in rows</span>
names = gp.names(sorted_indexes);

<span class="comment">%Find the limits of the error bars using two tail p-value=0.05</span>
sup_bound = random_values(:,round(gp.replicates * 0.975));
low_bound = random_values(:,round(gp.replicates * 0.025));

<span class="comment">%Plot the data of the real matrices</span>
figure(2);
plot(1:gp.n_networks, ntc_vals,<span class="string">'o'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'red'</span>,<span class="string">'MarkerEdgeColor'</span>,<span class="string">'red'</span>);
hold <span class="string">on</span>;
<span class="comment">%Plot the data of the random values</span>
errorbar(1:gp.n_networks, mean_random_vals, mean_random_vals - low_bound, <span class="keyword">...</span><span class="comment">,</span>
    sup_bound - mean_random_vals, <span class="string">'o'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'white'</span>,<span class="string">'MarkerEdgeColor'</span>,<span class="string">'black'</span>);
hold <span class="string">off</span>;

<span class="comment">%Write the labels</span>
set(gca,<span class="string">'xticklabel'</span>,[]);
<span class="keyword">for</span> i=1:gp.n_networks
    tmph=text(i,-0.01,names(i));
    set(tmph,<span class="string">'HorizontalAlignment'</span>,<span class="string">'right'</span>);
    set(tmph,<span class="string">'rotation'</span>,90);
    set(tmph,<span class="string">'fontsize'</span>,10);
<span class="keyword">end</span>

<span class="comment">%Labels in title, y-axis and legends</span>
tmplh = legend(<span class="string">'Measured modularity'</span>,<span class="string">'Random expectation'</span>,1,<span class="string">'Location'</span>,<span class="string">'NorthWest'</span>);
legend(<span class="string">'boxoff'</span>)
title(<span class="string">'Nestedness in Bacteria-Phage Networks'</span>,<span class="string">'fontsize'</span>,20);
ylabel(<span class="string">'Nestedness (NTC)'</span>,<span class="string">'fontsize'</span>,16);

<span class="comment">%Give format to the matrix</span>
xlim([1 1+gp.n_networks]);
ylim([0 1]);

<span class="comment">%Give appropiate size to the figure window</span>
set(gcf,<span class="string">'Position'</span>,[91   135   859   505]);
set(gca,<span class="string">'Units'</span>,<span class="string">'pixels'</span>);
set(gcf,<span class="string">'Position'</span>, [91   135   859   505+150])
apos = get(gca,<span class="string">'position'</span>);
apos(2) = apos(2) + 82;
set(gca,<span class="string">'position'</span>,apos);
set(gcf,<span class="string">'position'</span>,[91   135   859   596]);
</pre><img vspace="5" hspace="5" src="use_case_group_testing_02.png" alt=""> <p class="footer"><br>
      Published with MATLAB&reg; 7.13<br></p></div><!--
##### SOURCE BEGIN #####
%% BiMat - Group Testing Use case
% This use case will introduce the user to the functionalities about
% how to perform an statistical analysis of a group of bipartite networks
% (matrices). For doing that we will use the data from Flores et Al 2011.
% This data consist of 38 bipartite adjacency matrices of different sizes.
% Each matrix is named according to the first author paper
% from which it was extracted.
% We will perform an analysis of modularity and nestedness in the entire set.
%
%% Add the source to the matlab path
g = genpath('matlab'); addpath(g);
%%%
% We need also to load the data from which we will be working on
load group_testing_data.mat;

%% Creating a Group Testing object
% If the number of random matrices and the null model are not assigned, 100 and
% AVERAGE are used as default. Here we will use 100 random matrices with
% the EQUIPROBABLE null model
gp = GroupTesting(grouptesting.matrices);    % Create the main object

%% Perform an statististical analysis in the set of matrices
% Suppose that we are interested in calculating the modularity and
% nestedness using the NTC algorithm as Flores et Al 2011 did. In addition,
% following the approach of Flores et Al 2011, we want to use the
% equiprobable model as null model in our random networks. The way to
% perform this analysis is by running the next lines:
gp.replicates = 100; %How many random networks we want for each matrix
gp.null_model = @NullModels.EQUIPROBABLE; %Our Null model
gp.modul_class = @AdaptiveBrim; %Algorithm for modularity.
gp.do_temp = 1; % Perform NTC analysis (default)
gp.do_modul = 1; % Perform Modularity analysis (default)
gp.do_nest = 0; % Do not perform NODF analysis
gp.DoGroupTesting(); % Perform the analysis.
gp.names = grouptesting.name;
%%
% Notice that |DoGroupTesting| method prints informatino about the current
% networks that is being analyzed, such that the user will know at every
% moment the current status of the analysis.
% After the analysis is finished a simple statistical measure to say that a
% matrix is nested and/or modular is to chose a two tail p-value = 0.05 as
% Flores et al 2011 did. Therefore, the next lines of code will show how
% many matrices are found nested and/or modular
fprintf('Number of nested matrices: %i\n',sum(gp.tempvals.percent >= 97.5));
fprintf('Number of modular matrices: %i\n',sum(gp.qb_vals.percent >= 97.5));
%%
% We can also show the entire set of results by calling:
gp.PrintResults();

%% Using a GroupTesting object to create your own plots
% We can use a GroupTesting object (gp in this case) to create specific
% plots. Suppose we are interested in plotting all the matrices in modular
% sorting, such that the lables in the matrix are in red if the matrix is
% modular and in blue if it is antimodular. A simple script for performing
% this task will be:
n_rows = 5;
n_cols = 8;
modular_indices = gp.qb_vals.percent >= 97.5;
no_modular_indices = gp.qb_vals.percent <= 2.5;
figure(1);
for i = 1:gp.n_networks
    subplot(n_rows, n_cols, i);
    gp.networks{i}.plotter.use_labels = 0; %Do not show row/column labels
    gp.networks{i}.plotter.use_isocline = 0; %No isocline inside modules
    gp.networks{i}.plotter.PlotModularMatrix();
    col = 'black'; % Color for not significance
    if(modular_indices(i) == 1) % Color for significant modularity
        col = 'red';
    elseif(no_modular_indices(i) == 1) % Color for significant antimodularity
        col = 'blue';
    end
    title(gp.names{i},'Color',col, 'FontSize',10);
end
set(gcf,'Position', [148         213        1142         746]);
%%
% We may want to create a plot that compare the values of the networks with
% the random values of the null model. The next lines will show how to
% create such plot for the case of the NTC results
ntc_vals = gp.tempvals.value;
[~,sorted_indexes] = sort(ntc_vals); % I will plot in increasing NTC value

%Get random values and sort according to sorted_indexes
ntc_vals = ntc_vals(sorted_indexes);
mean_random_vals = gp.tempvals.mean(sorted_indexes);
random_values = gp.tempvals.random_values; %variable already sorted in rows
random_values = random_values(sorted_indexes,:); %sort in rows
names = gp.names(sorted_indexes);

%Find the limits of the error bars using two tail p-value=0.05
sup_bound = random_values(:,round(gp.replicates * 0.975));
low_bound = random_values(:,round(gp.replicates * 0.025));

%Plot the data of the real matrices
figure(2);
plot(1:gp.n_networks, ntc_vals,'o','MarkerFaceColor','red','MarkerEdgeColor','red');
hold on;
%Plot the data of the random values
errorbar(1:gp.n_networks, mean_random_vals, mean_random_vals - low_bound, ...,
    sup_bound - mean_random_vals, 'o','MarkerFaceColor','white','MarkerEdgeColor','black');
hold off;

%Write the labels
set(gca,'xticklabel',[]);
for i=1:gp.n_networks
    tmph=text(i,-0.01,names(i));
    set(tmph,'HorizontalAlignment','right');
    set(tmph,'rotation',90);
    set(tmph,'fontsize',10);
end

%Labels in title, y-axis and legends
tmplh = legend('Measured modularity','Random expectation',1,'Location','NorthWest');
legend('boxoff')
title('Nestedness in Bacteria-Phage Networks','fontsize',20);
ylabel('Nestedness (NTC)','fontsize',16);

%Give format to the matrix
xlim([1 1+gp.n_networks]);
ylim([0 1]);

%Give appropiate size to the figure window
set(gcf,'Position',[91   135   859   505]);
set(gca,'Units','pixels');
set(gcf,'Position', [91   135   859   505+150])
apos = get(gca,'position');
apos(2) = apos(2) + 82;
set(gca,'position',apos);
set(gcf,'position',[91   135   859   596]);



##### SOURCE END #####
--></body></html>