
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>TestModules</title><meta name="generator" content="MATLAB 7.13"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2013-05-20"><meta name="DC.source" content="TestModules.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><pre class="codeinput"><span class="comment">% TestModules Multi-scale statistical analysis for a bipartite complex</span>
<span class="comment">% network. This class performs modularity and nestedness analysis of the</span>
<span class="comment">% internal modules (after performing modularity algorithms) of the</span>
<span class="comment">% bipartite network. In addition, it can be used to calculate diversity</span>
<span class="comment">% index of the labels id's of rows and/or columns inside module to see if</span>
<span class="comment">% there exist a correlation between modularity labeling and type of nodes.</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">% TestModules Properties:</span>
<span class="comment">%   bipweb - Bipartite network object in which the multi-scale analysis will be performed</span>
<span class="comment">%	randomindex - Data structure used diversity of random permutation of labels of rows and columns.</span>
<span class="comment">%   realindex - Data structure used for the diversity of the original labeling sorting of rows and columns</span>
<span class="comment">%	rows_idx - Labeling of rows</span>
<span class="comment">%	cols_idx - Labeling of columns</span>
<span class="comment">%	module_networks - Cell composed of bipartite network objects which corresponds to the internal modules of biweb</span>
<span class="comment">%</span>
<span class="comment">% TestModules Methods:</span>
<span class="comment">%     TestModules - Main Constructor</span>
<span class="comment">%     DoNulls - Create random matrices for the statistical analysis</span>
<span class="comment">%     DoCompleteAnalysis - Perform the entire modularity and nestedness analysis</span>
<span class="comment">%     Nestedness - Perform the NODF Statistical Analysis</span>
<span class="comment">%     Temperature - Perform the NTC Statistical Analysis</span>
<span class="comment">%     MaxEigenvalue - Perform the spectral radius Statistical Analysis</span>
<span class="comment">%     Modularity - Perform the Modularity Statistical Analysis</span>
<span class="comment">%     NestednessContributions - Perform the nestedness contribution Statistical Analysis</span>
<span class="comment">%     GET_DEV_MODUL - Perform a Modularity Statistical Analysis</span>
<span class="comment">%     GET_DEV_NEST - Perform a NODF Statistical Analysis</span>
<span class="comment">%     GET_DEV_TEMP - Perform a NTC Statistical Analysis</span>
<span class="comment">%     GET_DEV_EIG - Perform a spectral radius Statistical Analysis</span>
<span class="comment">%     GET_NEST_CONTRIBUTIONS - Get NODF nestedness contributions of a</span>
<span class="comment">%</span>
<span class="comment">% See also:</span>
<span class="comment">%     BipartiteModularity, NODF, NestednessBINMATNEST</span>
<span class="keyword">classdef</span> TestModules &lt; handle

    <span class="keyword">properties</span>(GetAccess = <span class="string">'public'</span>, SetAccess = <span class="string">'public'</span>)
        bipweb          = []; <span class="comment">% Bipartite network object in which the multi-scale analysis will be performed</span>
        randomindex     = []; <span class="comment">% Data structure used diversity of random permutation of labels of rows and columns.</span>
        realindex       = []; <span class="comment">% Data structure used for the diversity of the original labeling sorting of rows and columns</span>
        rows_idx        = []; <span class="comment">% Labeling of rows</span>
        cols_idx        = []; <span class="comment">% Labeling of columns</span>
        module_networks = {}; <span class="comment">% Cell composed of bipartite network objects which corresponds to the internal modules of biweb</span>
        qb_vals         = [];
        nestvals        = [];
        tempvals        = [];
    <span class="keyword">end</span>

    <span class="keyword">methods</span>
        <span class="keyword">function</span> obj = TestModules(webbip)
        <span class="comment">% TestModules - Main Constructor</span>
            obj.bipweb = webbip;

        <span class="keyword">end</span>

        <span class="keyword">function</span> TestDiversityRows(obj,n_trials,rows_ids,index_function)
        <span class="comment">% TestDiversityRows - Function used for calculating the diverstiy</span>
        <span class="comment">% of the row labeling inside internal modules. The diversity is</span>
        <span class="comment">% calculated also in random permutations. The comparison of the</span>
        <span class="comment">% diversity of the original labeling and the random permutations</span>
        <span class="comment">% can be used to test if a correlation may exist between module</span>
        <span class="comment">% id's and row labeling. The function fill obj.randomindex.rows and</span>
        <span class="comment">% obj.realindex.rows of the TestModules object obj. The first</span>
        <span class="comment">% corresponds to the statistics of diversity of the random</span>
        <span class="comment">% permutations and the second one corresponds to the diversity</span>
        <span class="comment">% values of the original value.</span>
        <span class="comment">%</span>
        <span class="comment">%   obj = TestDiversityRows(obj) Calculate the statistics of</span>
        <span class="comment">%   diversity for row labeling using 100 random permutations, the</span>
        <span class="comment">%   original row labeling of the bipartite network object and the</span>
        <span class="comment">%   Simpson's diversity index.</span>
        <span class="comment">%</span>
        <span class="comment">%   obj = TestDiversityRows(obj,n_trials) Calculate the statistics of</span>
        <span class="comment">%   diversity for row labeling using n_trials random permutations, the</span>
        <span class="comment">%   original row labeling of the bipartite network object and the</span>
        <span class="comment">%   Simpson's diversity index.</span>
        <span class="comment">%</span>
        <span class="comment">%   obj = TestDiversityRows(obj,n_trials,rows_ids) Calculate the statistics of</span>
        <span class="comment">%   diversity for row labeling using n_trials random permutations, rows_ids</span>
        <span class="comment">%   as row labeling of the bipartite network object and the</span>
        <span class="comment">%   Simpson's diversity index.</span>
        <span class="comment">%</span>
        <span class="comment">%   obj = TestDiversityRows(obj,n_trials,rows_ids,index_function) Calculate the statistics of</span>
        <span class="comment">%   diversity for row labeling using n_trials random permutations, rows_ids</span>
        <span class="comment">%   as row labeling of the bipartite network object and the</span>
        <span class="comment">%   diversity function index_function</span>
        <span class="comment">%</span>
        <span class="comment">%  See also:</span>
        <span class="comment">%   Diversity.SHANNON_INDEX, Diversity.SIMPSON_INDEX</span>
            RandStream.setGlobalStream(RandStream(<span class="string">'mt19937ar'</span>,<span class="string">'seed'</span>,sum(100*clock)));
            assert(length(rows_ids)==obj.bipweb.modules.n_rows);

            <span class="keyword">if</span>(nargin == 1)
                n_trials = 100;
                rows_ids = obj.rows_idx;
                index_function = @Diversity.SIMPSON_INDEX;
            <span class="keyword">elseif</span>(nargin==2)
                rows_ids = obj.rows_idx;
                index_function = @Diversity.SIMPSON_INDEX;
            <span class="keyword">end</span>

            modul = obj.bipweb.modules;

            randomdata = zeros(n_trials, modul.N);
            prandom = zeros(1,modul.N);
            obj.realindex.rows = zeros(modul.N,1);
            obj.rows_idx = rows_ids;

            [row_modules, ~] = modul.ExtractCommunityIndexes();

            n = length(rows_ids);
            <span class="keyword">for</span> i = 1:modul.N

                obj.realindex.rows(i) = index_function(rows_ids(row_modules{i}));
                nr = length(row_modules{i});
                <span class="keyword">for</span> j = 1:n_trials
                    rows_idx_random = rows_ids(randperm(n));
                    randomdata(j,i) = index_function(rows_idx_random(1:nr));
                <span class="keyword">end</span>
                randomdata(:,i) = sort(randomdata(:,i));
                prandom(i) = sum(obj.realindex.rows(i)&gt;randomdata(:,i))/n_trials;
            <span class="keyword">end</span>
            obj.randomindex.rows.zscore = (obj.realindex.rows' - mean(randomdata))./std(randomdata);
            obj.randomindex.rows.data = randomdata;
            obj.randomindex.rows.p_values = prandom;

            fprintf(<span class="string">'Diversity in Rows unsing %s\n'</span>,func2str(index_function));
            fprintf(<span class="string">'Module \t index \t zscore \t percent \n'</span>);
            <span class="keyword">for</span> i = 1:modul.N
                fprintf(<span class="string">'%i \t %f \t %f \t %f \n'</span>, i, obj.realindex.rows(i), obj.randomindex.rows.zscore(i), obj.randomindex.rows.p_values(i));
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> TestDiversityColumns(obj,n_trials,cols_ids,index_function)
        <span class="comment">% TestDiversityColumns - Function used for calculating the diverstiy</span>
        <span class="comment">% of the column labeling inside internal modules. The diversity is</span>
        <span class="comment">% calculated also in random permutations. The comparison of the</span>
        <span class="comment">% diversity of the original labeling and the random permutations</span>
        <span class="comment">% can be used to test if a correlation may exist between module</span>
        <span class="comment">% id's and column labeling. The function fill obj.randomindex.cols and</span>
        <span class="comment">% obj.realindex.cols of the TestModules object obj. The first</span>
        <span class="comment">% corresponds to the statistics of diversity of the random</span>
        <span class="comment">% permutations and the second one corresponds to the diversity</span>
        <span class="comment">% values of the original value.</span>
        <span class="comment">%</span>
        <span class="comment">%   obj = TestDiversityColumns(obj) Calculate the statistics of</span>
        <span class="comment">%   diversity for column labeling using 100 random permutations, the</span>
        <span class="comment">%   original column labeling of the bipartite network object and the</span>
        <span class="comment">%   Simpson's diversity index.</span>
        <span class="comment">%</span>
        <span class="comment">%   obj = TestDiversityColumns(obj,n_trials) Calculate the statistics of</span>
        <span class="comment">%   diversity for column labeling using n_trials random permutations, the</span>
        <span class="comment">%   original column labeling of the bipartite network object and the</span>
        <span class="comment">%   Simpson's diversity index.</span>
        <span class="comment">%</span>
        <span class="comment">%   obj = TestDiversityColumns(obj,n_trials,cols_ids) Calculate the statistics of</span>
        <span class="comment">%   diversity for column labeling using n_trials random permutations, cols_ids</span>
        <span class="comment">%   as column labeling of the bipartite network object and the</span>
        <span class="comment">%   Simpson's diversity index.</span>
        <span class="comment">%</span>
        <span class="comment">%   obj = TestDiversityColumns(obj,n_trials,cols_ids,index_function) Calculate the statistics of</span>
        <span class="comment">%   diversity for column labeling using n_trials random permutations, cols_ids</span>
        <span class="comment">%   as column labeling of the bipartite network object and the</span>
        <span class="comment">%   diversity function index_function</span>
        <span class="comment">%</span>
        <span class="comment">%  See also:</span>
        <span class="comment">%   Diversity.SHANNON_INDEX, Diversity.SIMPSON_INDEX</span>

            RandStream.setGlobalStream(RandStream(<span class="string">'mt19937ar'</span>,<span class="string">'seed'</span>,sum(100*clock)));
            assert(length(cols_ids)==obj.bipweb.modules.n_cols);

            <span class="keyword">if</span>(nargin == 1)
                n_trials = 100;
                cols_ids = obj.cols_idx;
                index_function = @Diversity.SIMPSON_INDEX;
            <span class="keyword">elseif</span>(nargin==2)
                cols_ids = obj.cols_idx;
                index_function = @Diversity.SIMPSON_INDEX;
            <span class="keyword">end</span>

            modul = obj.bipweb.modules;

            randomdata = zeros(n_trials, modul.N);
            prandom = zeros(1,modul.N);
            obj.realindex.cols = zeros(modul.N,1);
            obj.cols_idx = cols_ids;

            [col_modules, ~] = modul.ExtractCommunityIndexes();

            n = length(cols_ids);
            <span class="keyword">for</span> i = 1:modul.N

                obj.realindex.cols(i) = index_function(cols_ids(col_modules{i}));
                nr = length(col_modules{i});
                <span class="keyword">for</span> j = 1:n_trials
                    cols_idx_random = cols_ids(randperm(n));
                    randomdata(j,i) = index_function(cols_idx_random(1:nr));
                <span class="keyword">end</span>
                randomdata(:,i) = sort(randomdata(:,i));
                prandom(i) = sum(obj.realindex.cols(i)&gt;randomdata(:,i))/n_trials;
            <span class="keyword">end</span>
            obj.randomindex.cols.zscore = (obj.realindex.cols' - mean(randomdata))./std(randomdata);
            obj.randomindex.cols.data = randomdata;
            obj.randomindex.cols.p_values = prandom;

            fprintf(<span class="string">'Diversity in Columns unsing %s\n'</span>,func2str(index_function));
            fprintf(<span class="string">'Module \t index \t zscore \t percent \n'</span>);
            <span class="keyword">for</span> i = 1:modul.N
                fprintf(<span class="string">'%i \t %f \t %f \t %f \n'</span>, i, obj.realindex.cols(i), obj.randomindex.cols.zscore(i), obj.randomindex.cols.p_values(i));
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> TestInternalModules(obj,n_trials,null_model)
        <span class="comment">% TestInternalModules - Function that calculate the modularity and</span>
        <span class="comment">% nestedness statistics of the internal modules of the bipartite</span>
        <span class="comment">% object obj.bipweb</span>
        <span class="comment">%</span>
        <span class="comment">%   obj = TestInternalModules(obj) It test for modularity, and</span>
        <span class="comment">%   nestedness the internal modules of the object obj.bipweb usin</span>
        <span class="comment">%   100 random matrices for each module and the EQUIPROBABLE null</span>
        <span class="comment">%   model.</span>
        <span class="comment">%</span>
        <span class="comment">%   obj = TestInternalModules(obj,n_trials) It test for modularity, and</span>
        <span class="comment">%   nestedness the internal modules of the object obj.bipweb usin</span>
        <span class="comment">%   n_trials random matrices for each module and the EQUIPROBABLE null</span>
        <span class="comment">%   model.</span>
        <span class="comment">%</span>
        <span class="comment">%   obj = TestInternalModules(obj,n_trials,null_model) It test for modularity, and</span>
        <span class="comment">%   nestedness the internal modules of the object obj.bipweb usin</span>
        <span class="comment">%   n_trials random matrices for each module and null_model as null</span>
        <span class="comment">%   model for creating the random matrices</span>


            <span class="keyword">if</span>(nargin == 1)
                n_trials = 100;
                null_model = @NullModels.EQUIPROBABLE;
            <span class="keyword">elseif</span>(nargin == 2)
                null_model = @NullModels.EQUIPROBABLE;
            <span class="keyword">end</span>

            obj.module_networks = obj.ExtractCommunityModules();

            qb.algorithm  = null_model;
            qb.replicates = n_trials;
            temp.algorithm  = null_model;
            temp.replicates = n_trials;
            nest.algorithm  = null_model;
            nest.replicates = n_trials;

            i = 1;
            <span class="keyword">for</span> net = obj.module_networks
                <span class="comment">%display(net{1}.adjacency);</span>
                <span class="keyword">if</span>(isempty(net{1}.webmatrix))
                    <span class="keyword">continue</span>;
                <span class="keyword">end</span>
                net{1}.tests.print_output = 0;
                net{1}.tests.DoCompleteAnalysis(n_trials,null_model);

                qb.value(i) = net{1}.tests.qb_vals.value;
                qb.p(i) = net{1}.tests.qb_vals.p;
                qb.ci(i,:) = net{1}.tests.qb_vals.ci;
                qb.zscore(i) = net{1}.tests.qb_vals.zscore;
                qb.percent(i) = net{1}.tests.qb_vals.percent;

                temp.value(i) = net{1}.tests.tempvals.value;
                temp.p(i) = net{1}.tests.tempvals.p;
                temp.ci(i,:) = net{1}.tests.tempvals.ci;
                temp.zscore(i) = net{1}.tests.tempvals.zscore;
                temp.percent(i) = net{1}.tests.tempvals.percent;

                nest.value(i) = net{1}.tests.nestvals.value;
                nest.p(i) = net{1}.tests.nestvals.p;
                nest.ci(i,:) = net{1}.tests.nestvals.ci;
                nest.zscore(i) = net{1}.tests.nestvals.zscore;
                nest.percent(i) = net{1}.tests.nestvals.percent;

                i = i+1;
            <span class="keyword">end</span>

            obj.qb_vals = qb;
            obj.nestvals = nest;
            obj.tempvals = temp;

            i = 1;
<span class="comment">%             fprintf('Module \t Modularity \t zscore \t percent \t NODF \t zscore \t percent \t NTC \t zscore \t percet \n');</span>
<span class="comment">%             for net = obj.module_networks</span>
<span class="comment">%                 if(isempty(net{1}.webmatrix))</span>
<span class="comment">%                     continue;</span>
<span class="comment">%                 end</span>
<span class="comment">%                 fprintf('%i \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \n', ...</span>
<span class="comment">%                 i, ...</span>
<span class="comment">%                 net{1}.tests.qb_vals.Qb, net{1}.tests.qb_vals.zscore, net{1}.tests.qb_vals.percent, ...</span>
<span class="comment">%                 net{1}.tests.nestvals.nodf, net{1}.tests.nestvals.zscore, net{1}.tests.nestvals.percent, ...</span>
<span class="comment">%                 net{1}.tests.tempvals.ntc, net{1}.tests.tempvals.zscore, net{1}.tests.tempvals.percent);</span>
<span class="comment">%</span>
<span class="comment">%                 i = i+1;</span>
<span class="comment">%             end</span>

        <span class="keyword">end</span>

        <span class="keyword">function</span> row_nets = TestRowsByLabeling(obj,rows_idx,n_trials,null_model)

            <span class="keyword">if</span>(nargin == 1)
                n_trials = 100;
                null_model = @NullModels.NULL_1;
                rows_idx = obj.bipweb.rows_idx;
            <span class="keyword">elseif</span>(nargin == 2)
                n_trials = 100;
                null_model = @NullModels.NULL_1;
            <span class="keyword">elseif</span>(nargin == 3)
                null_model = @NullModels.NULL_1;
            <span class="keyword">end</span>

            row_nets = obj.GetNetsByRowLabeling(rows_idx);

            TestModules.TestNetworks(row_nets,n_trials,null_model)

        <span class="keyword">end</span>

        <span class="keyword">function</span> inter_nets = TestByInteractions(obj,n_trials,null_model)

            <span class="keyword">if</span>(nargin == 1)
                n_trials = 100;
                null_model = @NullModels.NULL_1;
            <span class="keyword">elseif</span>(nargin == 2)
                n_trials = 100;
            <span class="keyword">end</span>

            inter_nets = obj.GetNetsByInteractions();

            TestModules.TestNetworks(inter_nets,n_trials,null_model)

        <span class="keyword">end</span>

        <span class="keyword">function</span> [nets row_idx] = GetNetsByRowLabeling(obj,row_labels)

            <span class="keyword">if</span>(nargin==1)
                row_labels = obj.bipweb.rows_idx;
            <span class="keyword">end</span>
            idx = unique(row_labels);
            n_nets = length(idx);
            nets = cell(n_nets,1);
            row_idx = cell(n_nets,1);
            matrix = obj.bipweb.webmatrix;

            <span class="keyword">for</span> i = 1:n_nets
                idx_rows = find(row_labels==idx(i));
                nets{i} = Bipartite(matrix(idx_rows,:));
                nets{i}.rows_idx = obj.bipweb.rows_idx(idx_rows);
                nets{i}.row_labels = obj.bipweb.row_labels(idx_rows);
                nets{i}.col_labels = obj.bipweb.col_labels;
                row_idx{i} = idx_rows;
            <span class="keyword">end</span>

        <span class="keyword">end</span>

        <span class="keyword">function</span> [nets row_idx col_idx]= GetNetsByInteractions(obj)

            matrix = obj.bipweb.webmatrix;
            idx = unique(matrix);
            <span class="keyword">if</span>(idx(1) == 0); idx(1) = []; <span class="keyword">end</span>;
            n_nets = length(idx);
            nets = cell(n_nets,1);
            row_idx = cell(n_nets,1);

            <span class="keyword">for</span> i = 1:n_nets
                [matrix_ex idx_rows idx_cols] = MatrixNull.TYPE_MATRIX_NON_ZERO(matrix, idx(i));
                nets{i} = Bipartite(matrix_ex);
                nets{i}.rows_idx = obj.bipweb.rows_idx(idx_rows);
                nets{i}.row_labels = obj.bipweb.row_labels(idx_rows);
                <span class="comment">%nets{i}.cols_idx = obj.bipweb.cols_idx(idx_cols);</span>
                nets{i}.col_labels = obj.bipweb.col_labels(idx_cols);
                row_idx{i} = idx_rows;
                col_idx{i} = idx_cols;
            <span class="keyword">end</span>

        <span class="keyword">end</span>

        <span class="keyword">function</span> networks = ExtractCommunityModules(obj)
            modul = obj.bipweb.modules;
            <span class="keyword">for</span> i = 1:modul.N
                idx_rows = find(modul.rr(:,i)==1);
                idx_cols = find(modul.tt(:,i)==1);
                ma = modul.webmatrix(idx_rows,idx_cols);
                networks{i} = Bipartite(ma);
                networks{i}.row_labels = obj.bipweb.row_labels(idx_rows);
                networks{i}.col_labels = obj.bipweb.col_labels(idx_cols);
                <span class="keyword">if</span>(~isempty(obj.bipweb.row_ids))
                    networks{i}.row_ids = obj.bipweb.row_ids(idx_rows);
                <span class="keyword">end</span>
                <span class="keyword">if</span>(~isempty(obj.bipweb.col_ids))
                    networks{i}.col_ids = obj.bipweb.col_ids(idx_cols);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> CreateModuleTableProperties(obj)

            modules = obj.module_networks;
            nn = length(modules);

            fprintf(<span class="string">'No. \t H \t P \t S \t I \t M \t C \t Lh \t Lp\n'</span>);

            <span class="keyword">for</span> i = 1:nn
                H = modules{i}.n_rows;
                P = modules{i}.n_cols;
                S = H+P;
                I = sum(sum(modules{i}.adjacency));
                M = H*P;
                C = I/M;
                Lh = I/H;
                Lp = I/P;
                fprintf(<span class="string">'%i \t %i \t %i \t %i \t %i \t %i \t %f \t %f \t %f\n'</span>, <span class="keyword">...</span>
                    i, H, P, S, I, M, C, Lh, Lp);
            <span class="keyword">end</span>

        <span class="keyword">end</span>

        <span class="keyword">function</span> TestNODFModuleContributions(obj)
            matrix = obj.bipweb.adjacency;
            rr = obj.bipweb.modules.rr;
            tt = obj.bipweb.modules.tt;

            [n_rows n_cols] = size(matrix);

            rows_sum = sum(matrix,2);
            col_sum = sum(matrix,1);

            [row,col] = find(rr);[a,ix] = sort(row);row_modules = col(ix);
            [row,col] = find(tt);[a,ix] = sort(row);col_modules = col(ix);

            nij_row_in = 0;
            nij_row_out = 0;
            <span class="keyword">for</span> i = 1:n_rows
                <span class="keyword">for</span> j = i+1:n_rows
                    cont = sum(matrix(i,:).*matrix(j,:))*(rows_sum(i)~=rows_sum(j))/min(sum(matrix(i,:)),sum(matrix(j,:)));
                    <span class="keyword">if</span>(~isnan(cont))
                        <span class="keyword">if</span>(row_modules(i) == row_modules(j))
                            nij_row_in = nij_row_in + cont;
                        <span class="keyword">else</span>
                            nij_row_out = nij_row_out + cont;
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            nij_col_in = 0;
            nij_col_out = 0;
            <span class="keyword">for</span> i = 1:n_cols
                <span class="keyword">for</span> j = i+1:n_cols
                    cont = sum(matrix(:,i).*matrix(:,j))*(col_sum(i)~=col_sum(j))/min(sum(matrix(:,i)),sum(matrix(:,j)));
                    <span class="keyword">if</span>(col_modules(i) == col_modules(j))
                        nij_col_in = nij_col_in + cont;
                    <span class="keyword">else</span>
                        nij_col_out = nij_col_out + cont;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            denom = n_rows*(n_rows-1)/2 + n_cols*(n_cols-1)/2;
            nodf_in = 100.0*(nij_row_in+nij_col_in)/denom;
            nodf_out = 100.0*(nij_row_out+nij_col_out)/denom;
            nodf = nodf_in + nodf_out;

        <span class="keyword">end</span>

    <span class="keyword">end</span>

    <span class="keyword">methods</span>(Static)

        <span class="keyword">function</span> TestNetworks(networks,n_trials,null_model)

            <span class="keyword">if</span>(nargin == 2)
                n_trials = 100;
                null_model = @NullModels.NULL_1;
            <span class="keyword">elseif</span>(nargin == 3)
                null_model = @NullModels.NULL_1;
            <span class="keyword">end</span>


            <span class="keyword">for</span> i = 1:length(networks)
                <span class="comment">%display(net{1}.adjacency);</span>
                <span class="keyword">if</span>(isempty(networks{i}.webmatrix))
                    <span class="keyword">continue</span>;
                <span class="keyword">end</span>
                networks{i}.tests.DoCompleteAnalysis(null_model,n_trials);

            <span class="keyword">end</span>

            fprintf(<span class="string">'Network \t Modularity \t zscore \t percent \t NODF \t zscore \t percent \t NTC \t zscore \t percet \n'</span>);
            <span class="keyword">for</span> i = 1:length(networks)
                <span class="keyword">if</span>(isempty(networks{i}.webmatrix))
                    <span class="keyword">continue</span>;
                <span class="keyword">end</span>
                fprintf(<span class="string">'%i \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \n'</span>, <span class="keyword">...</span>
                i, <span class="keyword">...</span>
                networks{i}.tests.qb_vals.Qb, networks{i}.tests.qb_vals.zscore, networks{i}.tests.qb_vals.percent, <span class="keyword">...</span>
                networks{i}.tests.nestvals.nodf, networks{i}.tests.nestvals.zscore, networks{i}.tests.nestvals.percent, <span class="keyword">...</span>
                networks{i}.tests.tempvals.ntc, networks{i}.tests.tempvals.zscore, networks{i}.tests.tempvals.percent);
            <span class="keyword">end</span>

        <span class="keyword">end</span>

    <span class="keyword">end</span>

<span class="keyword">end</span>
</pre><pre class="codeoutput">Error using TestModules (line 51)
Not enough input arguments.
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.13<br></p></div><!--
##### SOURCE BEGIN #####
% TestModules Multi-scale statistical analysis for a bipartite complex
% network. This class performs modularity and nestedness analysis of the
% internal modules (after performing modularity algorithms) of the
% bipartite network. In addition, it can be used to calculate diversity
% index of the labels id's of rows and/or columns inside module to see if
% there exist a correlation between modularity labeling and type of nodes.
% 
%
% TestModules Properties:
%   bipweb - Bipartite network object in which the multi-scale analysis will be performed
%	randomindex - Data structure used diversity of random permutation of labels of rows and columns.
%   realindex - Data structure used for the diversity of the original labeling sorting of rows and columns
%	rows_idx - Labeling of rows
%	cols_idx - Labeling of columns
%	module_networks - Cell composed of bipartite network objects which corresponds to the internal modules of biweb     
%
% TestModules Methods:
%     TestModules - Main Constructor
%     DoNulls - Create random matrices for the statistical analysis
%     DoCompleteAnalysis - Perform the entire modularity and nestedness analysis
%     Nestedness - Perform the NODF Statistical Analysis
%     Temperature - Perform the NTC Statistical Analysis
%     MaxEigenvalue - Perform the spectral radius Statistical Analysis
%     Modularity - Perform the Modularity Statistical Analysis
%     NestednessContributions - Perform the nestedness contribution Statistical Analysis
%     GET_DEV_MODUL - Perform a Modularity Statistical Analysis
%     GET_DEV_NEST - Perform a NODF Statistical Analysis
%     GET_DEV_TEMP - Perform a NTC Statistical Analysis
%     GET_DEV_EIG - Perform a spectral radius Statistical Analysis
%     GET_NEST_CONTRIBUTIONS - Get NODF nestedness contributions of a
%
% See also:
%     BipartiteModularity, NODF, NestednessBINMATNEST
classdef TestModules < handle
   
    properties(GetAccess = 'public', SetAccess = 'public')
        bipweb          = []; % Bipartite network object in which the multi-scale analysis will be performed
        randomindex     = []; % Data structure used diversity of random permutation of labels of rows and columns.
        realindex       = []; % Data structure used for the diversity of the original labeling sorting of rows and columns
        rows_idx        = []; % Labeling of rows
        cols_idx        = []; % Labeling of columns
        module_networks = {}; % Cell composed of bipartite network objects which corresponds to the internal modules of biweb
        qb_vals         = [];
        nestvals        = [];
        tempvals        = [];
    end
    
    methods
        function obj = TestModules(webbip)
        % TestModules - Main Constructor    
            obj.bipweb = webbip;

        end

        function TestDiversityRows(obj,n_trials,rows_ids,index_function)
        % TestDiversityRows - Function used for calculating the diverstiy
        % of the row labeling inside internal modules. The diversity is
        % calculated also in random permutations. The comparison of the
        % diversity of the original labeling and the random permutations
        % can be used to test if a correlation may exist between module
        % id's and row labeling. The function fill obj.randomindex.rows and
        % obj.realindex.rows of the TestModules object obj. The first
        % corresponds to the statistics of diversity of the random
        % permutations and the second one corresponds to the diversity
        % values of the original value.
        %
        %   obj = TestDiversityRows(obj) Calculate the statistics of
        %   diversity for row labeling using 100 random permutations, the
        %   original row labeling of the bipartite network object and the
        %   Simpson's diversity index.
        %
        %   obj = TestDiversityRows(obj,n_trials) Calculate the statistics of
        %   diversity for row labeling using n_trials random permutations, the
        %   original row labeling of the bipartite network object and the
        %   Simpson's diversity index.
        %
        %   obj = TestDiversityRows(obj,n_trials,rows_ids) Calculate the statistics of
        %   diversity for row labeling using n_trials random permutations, rows_ids
        %   as row labeling of the bipartite network object and the
        %   Simpson's diversity index.
        %
        %   obj = TestDiversityRows(obj,n_trials,rows_ids,index_function) Calculate the statistics of
        %   diversity for row labeling using n_trials random permutations, rows_ids
        %   as row labeling of the bipartite network object and the
        %   diversity function index_function
        %
        %  See also:
        %   Diversity.SHANNON_INDEX, Diversity.SIMPSON_INDEX
            RandStream.setGlobalStream(RandStream('mt19937ar','seed',sum(100*clock)));
            assert(length(rows_ids)==obj.bipweb.modules.n_rows);
            
            if(nargin == 1)
                n_trials = 100;
                rows_ids = obj.rows_idx;
                index_function = @Diversity.SIMPSON_INDEX;
            elseif(nargin==2)
                rows_ids = obj.rows_idx;
                index_function = @Diversity.SIMPSON_INDEX;
            end
            
            modul = obj.bipweb.modules;
            
            randomdata = zeros(n_trials, modul.N);
            prandom = zeros(1,modul.N);
            obj.realindex.rows = zeros(modul.N,1);
            obj.rows_idx = rows_ids;
            
            [row_modules, ~] = modul.ExtractCommunityIndexes();
            
            n = length(rows_ids);
            for i = 1:modul.N
                
                obj.realindex.rows(i) = index_function(rows_ids(row_modules{i}));
                nr = length(row_modules{i});
                for j = 1:n_trials
                    rows_idx_random = rows_ids(randperm(n));
                    randomdata(j,i) = index_function(rows_idx_random(1:nr));
                end
                randomdata(:,i) = sort(randomdata(:,i));
                prandom(i) = sum(obj.realindex.rows(i)>randomdata(:,i))/n_trials;
            end
            obj.randomindex.rows.zscore = (obj.realindex.rows' - mean(randomdata))./std(randomdata);
            obj.randomindex.rows.data = randomdata;
            obj.randomindex.rows.p_values = prandom;
            
            fprintf('Diversity in Rows unsing %s\n',func2str(index_function));
            fprintf('Module \t index \t zscore \t percent \n');
            for i = 1:modul.N
                fprintf('%i \t %f \t %f \t %f \n', i, obj.realindex.rows(i), obj.randomindex.rows.zscore(i), obj.randomindex.rows.p_values(i));
            end
        end
        
        function TestDiversityColumns(obj,n_trials,cols_ids,index_function)
        % TestDiversityColumns - Function used for calculating the diverstiy
        % of the column labeling inside internal modules. The diversity is
        % calculated also in random permutations. The comparison of the
        % diversity of the original labeling and the random permutations
        % can be used to test if a correlation may exist between module
        % id's and column labeling. The function fill obj.randomindex.cols and
        % obj.realindex.cols of the TestModules object obj. The first
        % corresponds to the statistics of diversity of the random
        % permutations and the second one corresponds to the diversity
        % values of the original value.
        %
        %   obj = TestDiversityColumns(obj) Calculate the statistics of
        %   diversity for column labeling using 100 random permutations, the
        %   original column labeling of the bipartite network object and the
        %   Simpson's diversity index.
        %
        %   obj = TestDiversityColumns(obj,n_trials) Calculate the statistics of
        %   diversity for column labeling using n_trials random permutations, the
        %   original column labeling of the bipartite network object and the
        %   Simpson's diversity index.
        %
        %   obj = TestDiversityColumns(obj,n_trials,cols_ids) Calculate the statistics of
        %   diversity for column labeling using n_trials random permutations, cols_ids
        %   as column labeling of the bipartite network object and the
        %   Simpson's diversity index.
        %
        %   obj = TestDiversityColumns(obj,n_trials,cols_ids,index_function) Calculate the statistics of
        %   diversity for column labeling using n_trials random permutations, cols_ids
        %   as column labeling of the bipartite network object and the
        %   diversity function index_function
        %
        %  See also:
        %   Diversity.SHANNON_INDEX, Diversity.SIMPSON_INDEX
                    
            RandStream.setGlobalStream(RandStream('mt19937ar','seed',sum(100*clock)));
            assert(length(cols_ids)==obj.bipweb.modules.n_cols);
            
            if(nargin == 1)
                n_trials = 100;
                cols_ids = obj.cols_idx;
                index_function = @Diversity.SIMPSON_INDEX;
            elseif(nargin==2)
                cols_ids = obj.cols_idx;
                index_function = @Diversity.SIMPSON_INDEX;
            end
            
            modul = obj.bipweb.modules;
            
            randomdata = zeros(n_trials, modul.N);
            prandom = zeros(1,modul.N);
            obj.realindex.cols = zeros(modul.N,1);
            obj.cols_idx = cols_ids;
            
            [col_modules, ~] = modul.ExtractCommunityIndexes();
            
            n = length(cols_ids);
            for i = 1:modul.N
                
                obj.realindex.cols(i) = index_function(cols_ids(col_modules{i}));
                nr = length(col_modules{i});
                for j = 1:n_trials
                    cols_idx_random = cols_ids(randperm(n));
                    randomdata(j,i) = index_function(cols_idx_random(1:nr));
                end
                randomdata(:,i) = sort(randomdata(:,i));
                prandom(i) = sum(obj.realindex.cols(i)>randomdata(:,i))/n_trials;
            end
            obj.randomindex.cols.zscore = (obj.realindex.cols' - mean(randomdata))./std(randomdata);
            obj.randomindex.cols.data = randomdata;
            obj.randomindex.cols.p_values = prandom;
            
            fprintf('Diversity in Columns unsing %s\n',func2str(index_function));
            fprintf('Module \t index \t zscore \t percent \n');
            for i = 1:modul.N
                fprintf('%i \t %f \t %f \t %f \n', i, obj.realindex.cols(i), obj.randomindex.cols.zscore(i), obj.randomindex.cols.p_values(i));
            end
        end
        
        function TestInternalModules(obj,n_trials,null_model)
        % TestInternalModules - Function that calculate the modularity and
        % nestedness statistics of the internal modules of the bipartite
        % object obj.bipweb
        %
        %   obj = TestInternalModules(obj) It test for modularity, and
        %   nestedness the internal modules of the object obj.bipweb usin
        %   100 random matrices for each module and the EQUIPROBABLE null
        %   model.
        %
        %   obj = TestInternalModules(obj,n_trials) It test for modularity, and
        %   nestedness the internal modules of the object obj.bipweb usin
        %   n_trials random matrices for each module and the EQUIPROBABLE null
        %   model.
        %
        %   obj = TestInternalModules(obj,n_trials,null_model) It test for modularity, and
        %   nestedness the internal modules of the object obj.bipweb usin
        %   n_trials random matrices for each module and null_model as null
        %   model for creating the random matrices
            
            
            if(nargin == 1)
                n_trials = 100;
                null_model = @NullModels.EQUIPROBABLE;
            elseif(nargin == 2)
                null_model = @NullModels.EQUIPROBABLE;
            end
            
            obj.module_networks = obj.ExtractCommunityModules();
            
            qb.algorithm  = null_model;
            qb.replicates = n_trials;
            temp.algorithm  = null_model;
            temp.replicates = n_trials;
            nest.algorithm  = null_model;
            nest.replicates = n_trials;
            
            i = 1;
            for net = obj.module_networks
                %display(net{1}.adjacency);
                if(isempty(net{1}.webmatrix))
                    continue;
                end
                net{1}.tests.print_output = 0;
                net{1}.tests.DoCompleteAnalysis(n_trials,null_model);
                
                qb.value(i) = net{1}.tests.qb_vals.value;
                qb.p(i) = net{1}.tests.qb_vals.p;
                qb.ci(i,:) = net{1}.tests.qb_vals.ci;
                qb.zscore(i) = net{1}.tests.qb_vals.zscore;
                qb.percent(i) = net{1}.tests.qb_vals.percent;
                
                temp.value(i) = net{1}.tests.tempvals.value;
                temp.p(i) = net{1}.tests.tempvals.p;
                temp.ci(i,:) = net{1}.tests.tempvals.ci;
                temp.zscore(i) = net{1}.tests.tempvals.zscore;
                temp.percent(i) = net{1}.tests.tempvals.percent;
                
                nest.value(i) = net{1}.tests.nestvals.value;
                nest.p(i) = net{1}.tests.nestvals.p;
                nest.ci(i,:) = net{1}.tests.nestvals.ci;
                nest.zscore(i) = net{1}.tests.nestvals.zscore;
                nest.percent(i) = net{1}.tests.nestvals.percent;
                
                i = i+1;
            end
            
            obj.qb_vals = qb;
            obj.nestvals = nest;
            obj.tempvals = temp;
            
            i = 1;
%             fprintf('Module \t Modularity \t zscore \t percent \t NODF \t zscore \t percent \t NTC \t zscore \t percet \n');
%             for net = obj.module_networks
%                 if(isempty(net{1}.webmatrix))
%                     continue;
%                 end
%                 fprintf('%i \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \n', ...
%                 i, ...
%                 net{1}.tests.qb_vals.Qb, net{1}.tests.qb_vals.zscore, net{1}.tests.qb_vals.percent, ...
%                 net{1}.tests.nestvals.nodf, net{1}.tests.nestvals.zscore, net{1}.tests.nestvals.percent, ...
%                 net{1}.tests.tempvals.ntc, net{1}.tests.tempvals.zscore, net{1}.tests.tempvals.percent);
%             
%                 i = i+1;
%             end
            
        end
        
        function row_nets = TestRowsByLabeling(obj,rows_idx,n_trials,null_model)
            
            if(nargin == 1)
                n_trials = 100;
                null_model = @NullModels.NULL_1;
                rows_idx = obj.bipweb.rows_idx;
            elseif(nargin == 2)
                n_trials = 100;
                null_model = @NullModels.NULL_1;
            elseif(nargin == 3)
                null_model = @NullModels.NULL_1;
            end
            
            row_nets = obj.GetNetsByRowLabeling(rows_idx);
            
            TestModules.TestNetworks(row_nets,n_trials,null_model)
            
        end
        
        function inter_nets = TestByInteractions(obj,n_trials,null_model)
            
            if(nargin == 1)
                n_trials = 100;
                null_model = @NullModels.NULL_1;
            elseif(nargin == 2)
                n_trials = 100;
            end
            
            inter_nets = obj.GetNetsByInteractions();
            
            TestModules.TestNetworks(inter_nets,n_trials,null_model)
            
        end
        
        function [nets row_idx] = GetNetsByRowLabeling(obj,row_labels)
            
            if(nargin==1)
                row_labels = obj.bipweb.rows_idx;
            end
            idx = unique(row_labels);
            n_nets = length(idx);
            nets = cell(n_nets,1);
            row_idx = cell(n_nets,1);
            matrix = obj.bipweb.webmatrix;
            
            for i = 1:n_nets
                idx_rows = find(row_labels==idx(i));
                nets{i} = Bipartite(matrix(idx_rows,:));
                nets{i}.rows_idx = obj.bipweb.rows_idx(idx_rows);
                nets{i}.row_labels = obj.bipweb.row_labels(idx_rows);
                nets{i}.col_labels = obj.bipweb.col_labels;
                row_idx{i} = idx_rows;
            end
            
        end
        
        function [nets row_idx col_idx]= GetNetsByInteractions(obj)
            
            matrix = obj.bipweb.webmatrix;
            idx = unique(matrix);
            if(idx(1) == 0); idx(1) = []; end;
            n_nets = length(idx);
            nets = cell(n_nets,1);
            row_idx = cell(n_nets,1);
            
            for i = 1:n_nets
                [matrix_ex idx_rows idx_cols] = MatrixNull.TYPE_MATRIX_NON_ZERO(matrix, idx(i));
                nets{i} = Bipartite(matrix_ex);
                nets{i}.rows_idx = obj.bipweb.rows_idx(idx_rows);                
                nets{i}.row_labels = obj.bipweb.row_labels(idx_rows);
                %nets{i}.cols_idx = obj.bipweb.cols_idx(idx_cols);
                nets{i}.col_labels = obj.bipweb.col_labels(idx_cols);
                row_idx{i} = idx_rows;
                col_idx{i} = idx_cols;
            end
            
        end
        
        function networks = ExtractCommunityModules(obj)
            modul = obj.bipweb.modules;
            for i = 1:modul.N
                idx_rows = find(modul.rr(:,i)==1);
                idx_cols = find(modul.tt(:,i)==1);
                ma = modul.webmatrix(idx_rows,idx_cols);
                networks{i} = Bipartite(ma);
                networks{i}.row_labels = obj.bipweb.row_labels(idx_rows);
                networks{i}.col_labels = obj.bipweb.col_labels(idx_cols);
                if(~isempty(obj.bipweb.row_ids))
                    networks{i}.row_ids = obj.bipweb.row_ids(idx_rows);
                end
                if(~isempty(obj.bipweb.col_ids))
                    networks{i}.col_ids = obj.bipweb.col_ids(idx_cols);
                end
            end 
        end
        
        function CreateModuleTableProperties(obj)
            
            modules = obj.module_networks;
            nn = length(modules);
            
            fprintf('No. \t H \t P \t S \t I \t M \t C \t Lh \t Lp\n');
            
            for i = 1:nn
                H = modules{i}.n_rows;
                P = modules{i}.n_cols;
                S = H+P;
                I = sum(sum(modules{i}.adjacency));
                M = H*P;
                C = I/M;
                Lh = I/H;
                Lp = I/P;
                fprintf('%i \t %i \t %i \t %i \t %i \t %i \t %f \t %f \t %f\n', ...
                    i, H, P, S, I, M, C, Lh, Lp);
            end
            
        end
        
        function TestNODFModuleContributions(obj)
            matrix = obj.bipweb.adjacency;
            rr = obj.bipweb.modules.rr;
            tt = obj.bipweb.modules.tt;
            
            [n_rows n_cols] = size(matrix);
            
            rows_sum = sum(matrix,2);
            col_sum = sum(matrix,1);
            
            [row,col] = find(rr);[a,ix] = sort(row);row_modules = col(ix);
            [row,col] = find(tt);[a,ix] = sort(row);col_modules = col(ix);
            
            nij_row_in = 0;
            nij_row_out = 0;
            for i = 1:n_rows
                for j = i+1:n_rows
                    cont = sum(matrix(i,:).*matrix(j,:))*(rows_sum(i)~=rows_sum(j))/min(sum(matrix(i,:)),sum(matrix(j,:)));
                    if(~isnan(cont))
                        if(row_modules(i) == row_modules(j))
                            nij_row_in = nij_row_in + cont;
                        else
                            nij_row_out = nij_row_out + cont;
                        end
                    end
                end
            end
            
            nij_col_in = 0;
            nij_col_out = 0;
            for i = 1:n_cols
                for j = i+1:n_cols
                    cont = sum(matrix(:,i).*matrix(:,j))*(col_sum(i)~=col_sum(j))/min(sum(matrix(:,i)),sum(matrix(:,j)));
                    if(col_modules(i) == col_modules(j))
                        nij_col_in = nij_col_in + cont;
                    else
                        nij_col_out = nij_col_out + cont;
                    end
                end
            end
            
            denom = n_rows*(n_rows-1)/2 + n_cols*(n_cols-1)/2;
            nodf_in = 100.0*(nij_row_in+nij_col_in)/denom;
            nodf_out = 100.0*(nij_row_out+nij_col_out)/denom;
            nodf = nodf_in + nodf_out;
                
        end
        
    end
    
    methods(Static)
       
        function TestNetworks(networks,n_trials,null_model)
            
            if(nargin == 2)
                n_trials = 100;
                null_model = @NullModels.NULL_1;
            elseif(nargin == 3)
                null_model = @NullModels.NULL_1;
            end
                        
            
            for i = 1:length(networks)
                %display(net{1}.adjacency);
                if(isempty(networks{i}.webmatrix))
                    continue;
                end
                networks{i}.tests.DoCompleteAnalysis(null_model,n_trials);
                
            end
            
            fprintf('Network \t Modularity \t zscore \t percent \t NODF \t zscore \t percent \t NTC \t zscore \t percet \n');
            for i = 1:length(networks)
                if(isempty(networks{i}.webmatrix))
                    continue;
                end
                fprintf('%i \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \n', ...
                i, ...
                networks{i}.tests.qb_vals.Qb, networks{i}.tests.qb_vals.zscore, networks{i}.tests.qb_vals.percent, ...
                networks{i}.tests.nestvals.nodf, networks{i}.tests.nestvals.zscore, networks{i}.tests.nestvals.percent, ...
                networks{i}.tests.tempvals.ntc, networks{i}.tests.tempvals.zscore, networks{i}.tests.tempvals.percent);
            end
            
        end
        
    end
    
end
##### SOURCE END #####
--></body></html>