---
layout: page
title: "Modularity"
category: alg
date: 2013-06-06 11:01:37
order: 0
---
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
--><div class="content"><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Description</a></li><li><a href="#2">Functions</a></li><li><a href="#3">Example 1: Calculating Modularity</a></li><li><a href="#6">Example 2: Accesing detailed results</a></li></ul></div><h2>Description<a name="1"></a></h2><p>Modularity is a ...</p><div><ul><li><b>LPBrim:</b></li><li><b>Brim:</b></li><li><b>Leading-Eigenvector:</b></li></ul></div><h2>Functions<a name="2"></a></h2><h2>Example 1: Calculating Modularity<a name="3"></a></h2><p>The next example shows how to detect modularity using the default algorithm:</p><pre class="codeinput">matrix = MatrixFunctions.BLOCK_MATRIX(2,10);
bp = Bipartite(matrix);
bp.community.Detect();
</pre><pre class="codeoutput">Modularity:
	Used algorithm:             	        AdaptiveBrim
	N (Number of modules):      	                   2
	Qb (Standard metric):       	              0.5000
	Qr (Ratio of int/ext inter):	              1.0000
</pre><p>We can also change the default algorithm before detecting the community structure, choosing among one of the three options described before:</p><pre class="codeinput">bp.community = LPBrim(matrix);
bp.community.Detect();
</pre><pre class="codeoutput">Modularity:
	Used algorithm:             	              LPBrim
	N (Number of modules):      	                   2
	Qb (Standard metric):       	              0.5000
	Qr (Ratio of int/ext inter):	              1.0000
</pre><p>Further, there is no need to work directly with a <tt>bipartite</tt> instance. The user can also chose to work with a <tt>BipartiteModularity</tt> instance instead:</p><pre class="codeinput"><span class="comment">%By creating an instance and then calculating modularity</span>
com = LeadingEigenvector(matrix);
com.Detect();
<span class="comment">%Or by calling a static method:</span>
com2 = BipartiteModularity.LEADING_EIGENVECTOR(matrix);
</pre><pre class="codeoutput">Modularity:
	Used algorithm:             	  LeadingEigenvector
	N (Number of modules):      	                   2
	Qb (Standard metric):       	              0.5000
	Qr (Ratio of int/ext inter):	              1.0000
Modularity:
	Used algorithm:             	  LeadingEigenvector
	N (Number of modules):      	                   2
	Qb (Standard metric):       	              0.5000
	Qr (Ratio of int/ext inter):	              1.0000
</pre><h2>Example 2: Accesing detailed results<a name="6"></a></h2><p>Altough by calculating the modularity we can already see what are the modularity results, sometimes we may need to know detailed values. By just typing the name of the <tt>BipartiteModularity</tt> instance we have access to these values:</p><pre class="codeinput">com2
</pre><pre class="codeoutput">
com2 = 

  LeadingEigenvector with properties:

    DoKernighanLinTunning: 1
                   matrix: [20x20 logical]
                   n_rows: 20
                   n_cols: 20
                  n_edges: 200
                       bb: [20x20 double]
               index_rows: [20x1 double]
               index_cols: [20x1 double]
                   trials: 20
                       Qb: 0.5000
                       Qr: 1
                        N: 2
              row_modules: [20x1 double]
              col_modules: [20x1 double]
                     done: 1
    optimize_by_component: 0
            print_results: 0

</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Modularity

%% Description
% Modularity is a ...
%
% * *LPBrim:*
% * *Brim:*
% * *Leading-Eigenvector:*

%% Functions

%% Example 1: Calculating Modularity
% The next example shows how to detect modularity using the default algorithm:
%
matrix = MatrixFunctions.BLOCK_MATRIX(2,10);
bp = Bipartite(matrix);
bp.community.Detect();
%%
% We can also change the default algorithm before detecting the community
% structure, choosing among one of the three options described before:
bp.community = LPBrim(matrix);
bp.community.Detect();
%%
% Further, there is no need to work directly with a |bipartite| instance. The user can
% also chose to work with a |BipartiteModularity| instance instead:
%By creating an instance and then calculating modularity
com = LeadingEigenvector(matrix);
com.Detect();
%Or by calling a static method:
com2 = BipartiteModularity.LEADING_EIGENVECTOR(matrix);

%% Example 2: Accesing detailed results
% Altough by calculating the modularity we can already see what are the
% modularity results, sometimes we may need to know detailed values. By
% just typing the name of the |BipartiteModularity| instance we have access
% to these values:
com2
##### SOURCE END #####
-->
